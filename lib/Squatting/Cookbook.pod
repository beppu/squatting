=head1 NAME

Squatting::Cookbook - Web Development Techniques for Squatting

=head1 INTRODUCTION

Squatting exists because I fell in love with Camping's API, and I couldn't bear
the thought of building another site using some other API.  When I decided that
the next site I wanted to build would be implemented in Perl, I had no choice
but to port Camping to Perl, and that's how Squatting was born.

My hope is that other Perl programmers will be able to appreciate how concise
this API is, and I hope they'll see just how far a little bit of code can go.

=head2 Anatomy of a Squatting Application

=head3 Make a Subclass of Squatting

  package App;
  use base 'Squatting';
  our %CONFIG = ();

=head3 Make a Package for Your Controllers

If your app is called C<App>, then:

=over 4

=item Your controllers must be defined in a package called C<App::Controllers>.

=item You must say C<use Squatting ':controllers'>.

=item You must put your controllers in a package variable named C<@C>.

=back

  package App::Controllers;
  use Squatting ':controllers';
  our @C = (
    C(
      Home => [ '/' ],
      get  => sub {
        my ($self) = @_;
        $self->render('home');
      }
    ),
    C(
      Profile => [ '/~(\w+)' ],
      get => sub {
        my ($self, $name) = @_;
        my $v = $self->v;
        $v->{name} = $name;
        $self->render('profile');
      }
    )
  );

=head4 Anatomy of a Controller

=head3 Make a Package for Your Views

If your app is called C<App>, then:

=over 4

=item Your views must be defined in a package called C<App::Views>.

=item You must say C<use Squatting ':views'>.

=item You must put your views in a package variable named C<@V>.

=back

  package App::Views;
  use Squatting ':views';
  our @V = (
    V(
      'html',
      layout => sub {
      },
      home => sub {
      },
      profile => sub {
      },
    )
  );

=head4 Anatomy of a View



=head1 PROGRAMMING TECHNIQUES

=head2 COMET

=head3 Event Architecture

=head3 RESTless Controllers


=head2 How to Set Up Sessions

=head3 Continuity and Process Memory

Pure Continuity apps typically don't use persistent session storage, because
they can use lexically scoped variables instead.  However, Squatting apps are
RESTful and stateless by default, so you can't count on the lexical scope of a
controller to stick around between requests.  Luckily, package variables *will*
stick around, so that's what we'll use to implement persistent sessions.

  our %state;
  sub service {
    my ($app, $c, @args) = @_;
    my $cr  = $c->cr;
    my $sid = $cr->{session_id};
    if (defined $sid) {
      $c->state = $state{$sid} ||= {};
    } 
    $app->next::method($c, @args);
  }

Here, we override service() in the main module of our app so that $c->state will
provide a hashref whose values will persist between requests.

Note that instead of writing C<$app-E<gt>SUPER::service>, we have to write
C<$app-E<gt>next::method>, because Squatting is a sublcass of
L<Class::C3::Componentised>.


=head3 When Squatting::On::Catalyst

When squatting on top of Catalyst, the Catalyst session becomes
C<$self-E<gt>state> in Squatting.  The session storage code in Catalyst is very
mature, so it is highly recommended that all the session setup be done on the
Catalyst side.


=head3 Sessions From Scratch

The challenge is to find a way to assign unique session ids to each visitor, and
use that session id as a key into a persistent store.  TMTOWTDI


=head2 How to Use Various Templating Systems With Squatting

=head3 HTML::AsSubs

I like L<HTML::AsSubs>, because the code is really small, and it basically
works.  It's not perfect, and the documentation is very clear on some of its
minor shortcomings.  However, the docs go a bit too far, and recommend that this
module not even be used!  It says that there are "cleaner" alternatives, but when
I looked at them, I came straight back to HTML::AsSubs.



=head3 Tenjin

=head3 Template::Toolkit

=head3 HTML::Mason

=head3 HTML::Template


=head2 How to Internationalize and Localize Squatting Apps

=head3 Using Subdomains For Maximum Flexibility

=head3 Locale::Maketext


=head2 How to be an OpenID Consumer

TODO - go into much more detail.

helper function for making a Net::OpenID::Consumer object

  sub csr {
    my ($self) = @_;
    return Net::OpenID::Consumer->new(
      ua    => LWPx::ParanoidAgent->new,
      cache => Cache::File->new(cache_root => '/tmp/openid-consumer-cache'),
      args  => $self->input,
      consumer_secret => '...',
      required_root   => 'http://work:4234/'
    );
  }

Login controller; form is provided somewhere else; POST is the entry point; 
GET is where the sequence finishes.

  C(
    Login => [ '/login' ],
    get => sub {
      my ($self) = @_;
      my $csr = csr($self);
      $self->headers->{'Content-Type'} = 'text/plain';
      if (my $setup_url = $csr->user_setup_url) {
        # redirect/link/popup user to $setup_url
        $self->redirect($setup_url);
        return;
      } elsif ($csr->user_cancel) {
        # restore web app state to prior to check_url
        return "user_cancel";
      } elsif (my $vident = $csr->verified_identity) {
         my $verified_url = $vident->url;
         return "verified_url $verified_url !";
      } else {
         return "Error validating identity: " . $csr->err;
      }
    },
    post => sub {
      my ($self) = @_;
      my $input = $self->input;
      my $csr = csr($self);
      my $claimed_identity = $csr->claimed_identity($input->{openid});
      my $check_url = $claimed_identity->check_url(
        return_to  => "http://work:4234/login",
        trust_root => "http://work:4234/",
      );
      $self->redirect($check_url);
    },
  ),

=head2 How to be an OpenID Provider



=head2 How to Compose Multiple Squatting Apps Into One App

  App->mount('AnotherApp', '/prefix');


=head2 How to Embed a Squatting App Into Other Frameworks

In order to embed a Squatting app into an app written in another
framework, we need to be able to do the following things.

=over 4

=item get incoming CGI parameters

=item get incoming HTTP request headers

=item get incoming HTTP method

=item set outgoing HTTP status

=item set outgoing HTTP response headers

=item set outgoing content

=back

If we can do all these things, Squatting can make itself at home.
Here are some concrete examples to get you started.

=head3 Catalyst

To embed a Squatting app into a Catalyst app, you can add code like
this to your C<Root> controller.

  use App 'On::Catalyst';
  App->init;
  App->relocate('/somewhere');
  sub somewhere : Local { App->catalyze($_[1]) }

If you want the Squatting app to be completely in charge, you don't
even have to relocate() -- just redefine the default() method like
this:

  use App 'On::Catalyst';
  App->init;
  sub default : Private { App->catalyze($_[1]) }

=head3 Raw mod_perl1

=head3 Raw mod_perl2

=head3 HTML::Mason

TODO:  Implement a dhandler that embeds a Squatting app

=head3 CGI

To run a Squatting app in a CGI environment, a script like this has
to be written.

  use App 'On::CGI';
  my $q = CGI->new;
  App->init;
  App->relocate('/cgi-bin/app.cgi');
  App->cgi($q);

The key to doing this right is to C<relocate> the app correctly.
The path that you relocate to should be the same as the C<REQUEST_PATH>
for the script.  For example, if the URL you use to get to the script
is http://localhost/cgi-bin/app.cgi , then you should relocate to
F</cgi-bin/app.cgi>.

=head1 DEPLOYMENT TECHNIQUES

=head2 Let Squatting+Continuity Own Port 80

This is the simplest thing you could possibly do, but it's also somewhat
limiting.

=head2 Reverse Proxying to Squatting+Continuity w/ Perlbal

=head2 Reverse Proxying to Squatting+Continuity w/ nginx

=head2 Piggy-Backing on Top of Other Frameworks

If you've embedded a Squatting app into another application, the rules and
conventions governing the other application's framework take precedence.
Follow their deployment guidelines, and you should be fine.


=head1 SCALING TECHNIQUES

This section is for those who wish to scale Squatting apps that are using a
Continuity foundation.  If any part of your site is RESTless and stateful, and
you've suddenly got a lot of traffic to your site, this section is for you.

=head2 Session Affinity with Multiple Instances

TODO

=for later
L<http://onsmalltalk.com/programming/smalltalk/seaside/scaling-seaside-more-advanced-load-balancing-and-publishing/>

=head2 Linux and OpenSSI

TODO

=head2 DragonFlyBSD Single Image Cluster

This is currently science fiction.


=cut
